# Отчёт по лабораторной работе №3

- Выполнил: Тюрин Святослав
- Группа: P33302
- Вариант: `forth | stack | harv | hw | tick | struct | trap | mem | pstr | prob1 | spi`

  CI status

  ## Язык программирования

  По варианту необходимо реализовать Forth-подобный язык.
  
```bnf
<program> ::= <expression>
<expression> ::= <expression> | <expression> <expression>
<expression> ::= <if-else-expression> | <do-loop-expression> | <begin-until-expression> | <words>
<if-else-expression> ::= "if " <expressions> [else <expressions>] " then"
<do-loop-expression> ::= "do " i <expressions> " loop"
<begin-until-expression> ::= "begin " <expressions> " until"
<words> ::=   <целочисленный литерал> | <math-op> | <stack-op> |<отображение строки> | <название процедуры> |
            "mod" | "key" | "." | "emit" | <переменная> | "@" | "!" | "ei" | "di" | "and" | "or" | "invert"
<math-op> ::= ">" | "<" | "=" |  "+" | "-" | “*” | “/” |
<stack-op> ::= | "drop" | "swap" | "over" | "dup"
<defun-expression> ::= ": " <название процедуры> <expressions> " ;"
<var-expression> ::= “variable ” <название переменной>
<string> ::=  "." <строка>
```
- `целочисленный литерал` - ложит значение на стек
- `math-op` - выполняет математическое действие между двумя последними значениями на стеке, вторым операндом берётся значение с вершины стека, операнды снимаются со стека, результат записывается на стек.
- `drop` - ( n -- ) убирает значение со стека
- `swap` -  ( n1 n2 -- n2 n1 ) меняет местами два последних значения на стеке
- `over` - ( n1 n2 -- n1 n2 n1 ) Берёт второй элемент со стека и дублирует его на вершину стека
- `"dup` - ( n -- n n ) дублирует последние значение на стеке
- `.` - ( n -- ) выводит последний элемент стека на стандартный поток вывода в виде числа
- `emit` - ( n -- ) выводит последний элемент стека в стандартный поток вывода в виде символа ASCII
- `key` - ( -- n) ввод символа с потока ввода
- `@` - (n1 -- n2) прочитать значение из памяти по адрессу n1 и положить его на стек
- `!` - (n1 n2 -- ) записать значение n1 в память по адрессу n2

Булевые значения, ложное значение "0", истинное значение любое другое число, каноническая версия "-1".

Объявление переменной `variable <varName>` создаёт переменную, по varName можно получить её адресс в памяти. При добавление слова `alot` можно выделить в памяти участок определённого размера, с помощью этого можно реализовать аналог массивов в языке C.

Оператор `if` выполняется в зависимости от "истинности" значения на вершине стека. Таким образом `0 = if ." Yes!" else ." No!" then ;` эквивалентно `if(flag) {print("Yes!")} else {print("No!)}`

Цикл `do-loop` похож на циклы в других C-подобных языках, внутри тела цикла с помощью ключевого слова `i` можно положить текущие значение индекса на стек. Два верхних значения на стеке дают конечное значение (не включая) и начальное значение(включительно). Таким образом `10 0 do i . loop` эквивалентно `for (int i = 0; i < 10; i++) { print(i); }`

Цикл `begin-until` работает как цикл while, каждый раз когда встречается слово until проверяется значение на стеке, и если оно истинно то мы возвращаемся к слову begin, если ложно то выполнение продолэжается. Таким образом `5 begin dup . 1 - until` эквивалентно `int i = 5; while(i != 0){ print(i); i -=1;}`


